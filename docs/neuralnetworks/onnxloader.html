<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Read ONNX File</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/protobufjs/dist/protobuf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.webgpu.min.js"></script>
    <script src="../../typetheory.js" ></script>
    <script src="../../definitions.js" charset="utf-8"></script>
    <link rel="stylesheet" type="text/css" href="../doc.css" >
</head>
<body>
    <div class="content">
        <h1>Neural Networks</h1>
        Click to load a neural network (ONNX) file and display it as a graph<br>
        (Note: It only displays one output)<br>
    <input type="file" id="fileInput" >
    <br>
    <div id="output"></div>
    <script>
        createInput(
``
        )
    </script>
<!---
    <script>
        createInput(
`FUN( MultiArray(Float32,LIST(1,10)),a=> 
FUN( MultiArray(Float32,LIST(1,10)),b=>
plus(a.type,a,b)
))`
        )
    </script>

    <script>
createInput(`
myVNN( MultiArray.fromList(Float32, LIST(1,1,28,28),toList( [
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], Float32 ) ) )
`)

    </script>
--->
    <script>
        var NNnum=0;
        var nameToObj={}
        var nodeList=[]
        var inputList=[]
        var outputTypes=[]
        var outputNames=[]
        var elemArray = [null,Float32Array, Uint8Array, Int8Array,Uint16Array, Int16Array,Int32Array,BigInt64Array,null,null,null,Float64Array,Uint32Array,BigUint64Array,null,null,null]
        var elemNames = [null,'float32','uint8','int8','uint16','int16','int32','int64','string','bool','float16','float64','uint32','uint64','complex64','complex128','bfloat16']
        var elementType = [null,Float32,UInt8,Int8,UInt16,Int16,Int32,Int64,String,Bool,Float16,Float64,UInt32,UInt64,Complex(Float32),Complex(Float64),BFloat16]
        function getType(t){
            var shape=[]
            var dims= t.tensorType.shape.dim;
            for(var i=0;i<dims.length;i++) {
                if(dims[i].dimValue) shape.push( dims[i].dimValue )
                else  shape.push( 1 ) //<---hack
            }
            //console.log("shape",shape);
            return {type:MultiArray(  elementType[ t.tensorType.elemType   ]  ,  toList(shape,Nat)),shape:shape};
        }
        function removeItem(arr, name) {
            value = nameToObj[name];
            var index = arr.indexOf(value);
            if (index > -1) {
                arr.splice(index, 1);
            }
            return arr;
        }

        
        

        document.getElementById('fileInput').addEventListener('change', function(event) {
            file = event.target.files[0];
            console.log("file",file);
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const arrayBuffer = e.target.result;
                    const uint8Array = new Uint8Array(arrayBuffer);

                    // Load the ONNX .proto definition from a URL
                    protobuf.load("https://raw.githubusercontent.com/onnx/onnx/main/onnx/onnx.proto", function(err, root) {
                        if (err) {
                            console.error("Failed to load protobuf definitions:", err);
                            return;
                        }

                        nameToObj={}
                        nodeList=[]
                        inputShapes=[]
                        inputList=[]
                        outputTypes=[]

                        // Obtain the message type
                        const ModelProto = root.lookupType("onnx.ModelProto");

                        // Decode the ONNX file
                        const message = ModelProto.decode(uint8Array);
                        console.log(message)
                        console.log("********VERSION "+message.irVersion+ " ****************")
                        if(message.irVersion<7) print(red(normal("Warning irVersion < 7" )))
                        // Extract and display variable names and layer names
                        const graph = message.graph;
                        let output = "";

                        
                        output += 'Input variables:\n';
                        graph.input.forEach(input => {
                            output += 'Name: ' + input.name + '\n';
                            var z=getType(input.type);
                            var inputType = z.type;
                            

                            var a = new C(input.name,inputType);
                            a.shape = z.shape //store the shape on the object
                            a.elemType = input.type.tensorType.elemType;
                            nodeList.push(a)
                            inputList.push(a)
                            nameToObj[input.name] = a;
                        });

                        output += '\nOutput variables:\n';
                        graph.output.forEach(outputVar => {
                            output += 'Name: ' + outputVar.name + '\n';
                            outputTypes.push( getType(outputVar.type).type)
                            outputNames.push( outputVar.name);
                        });

                        output += '\nInitializer variables:\n';
                        var i=0;
                        graph.initializer.forEach(initializer => {
                            output += 'Name: ' + initializer.name + '\n';                         
                            var a = new C("data "+i ,Type); //initializer.name //"("+initializer.dims.join(",")+")"
                            //nodeList.push(a)
                            inputList = removeItem(inputList,initializer.name);
                            nameToObj[initializer.name] = a;                          
                            i++;
                        });

                        output += '\nLayers:\n';
                        graph.node.forEach(node => {
                            output += 'Name: ' + node.name + ', OpType: ' + node.opType + '\n';

                            var a = new AppliedList();
                            var s= node.opType;
                            //if(s=="Constant") s=node.output[0];
                            if(s.length>8) s=s.slice(0,8)+"..";
                            var b;
                            if(s=="Add" && false){
                                b = plus;
                                a.second.push(Type);
                            }else{
                                b = new C(s,Type);
                            }
                            a.first = b;
                            for(var i=0;i<node.input.length;i++){
                                var c=nameToObj[node.input[i]];
                                a.second.push(c)
                                edgeList.push([a,c])
                            }
                            nodeList.push(a)
                            if(node.output.length!=1){
                                console.log("Error number of outputs="+node.output.length);
                            }
                            nameToObj[node.output[0]] = a//nodeList.length-1
                        });
                        
                        //document.getElementById('output').innerText = output;
                        //console.log("nameToObj",nameToObj)
                        //console.log("nodeList",nodeList);
                        //console.log("edgeList",edgeList);
                        //console.log(graph.output[0].name)
                        var outputObj = nameToObj[graph.output[0].name]
                        //console.log(outputObj)
                        window.result=outputObj;
                        
                        //showEqGraph("output");

                        var graphName = "NeuralNet"+(++NNnum);
                        

                        //console.log("outputObj.type",outputObj.type)
                        //console.log("output", outputTypes[0])

                        //create function object
                        if(!true){
                            var funcObj = outputObj;
                            console.log("inputList",inputList)
                            for(var i=0;i<inputList.length;i++){
                                funcObj = FUN( inputList[i].type , x=>REPLACE(funcObj,inputList[i],x))
                                //new Fun(inputList[i], x=>REPLACE(funcObj,inputList[i],x) )
                            }
                            window.myNN=defineVar("myNN", funcObj);
                        }
                        //create virtual NN object
                        if(true){
                            var T=outputTypes[0];
                            for(var i=0;i<inputList.length;i++){
                                T=new F(inputList[i].type,T);
                                window[graphName]= Var(graphName,T);
                            }
                            
                            print(window[graphName]+":"+window[graphName].type)
                            MathJax.typeset()
                        }

                        if(!true){
                            print(outputObj)
                            console.log("MathJax",MathJax);
                            //if(MathJax!=null) MathJax.typeset()
                            MathJax.typesetPromise([document.getElementById("output")]).then(() => {
                                //console.log("Typesetting complete.");
                            }).catch((err) => console.error(err.message));
                        }
                        //eqGraph(outputObj)
                    });
                };
                reader.readAsArrayBuffer(file);

                
            }
        });

        function createRandomArray(e,length) {
            console.log(">>",elemNames[e])
            const f = elemArray[e];
            console.log(f);
            const array = new f(length);
            if(e==7){
                for (let i = 0; i < length; i++) array[i] = BigInt(Math.floor(Math.random()*2));
            }
            else{
                for (let i = 0; i < length; i++) array[i] = Math.random();
            }
            return array;
        }

        async function runInference() {
            // const modelPath = '/model.onnx'; // Update this to the correct path
            const arrayBuffer = await file.arrayBuffer();
            const modelPath = arrayBuffer//'/GPT2/decoder_model.onnx' 
            const session = await ort.InferenceSession.create(modelPath, {
                    executionProviders: ['webgpu']
                });
                var inputs=[];
                var feeds={};
                for(var i=0;i<inputList.length;i++){
                    var e  = inputList[i].elemType;
                    const inputBuffer = createRandomArray(e,arrayProd( inputList[i].shape  ) ); 
                    const a = new ort.Tensor(elemNames[e] ,inputBuffer, inputList[i].shape );
                    feeds[inputList[i].symbol] = a;
                    console.log("Input="+inputList[i].symbol+" "+inputList[i].shape)
                }

                /*const inputGpuBuffer1 = new Float32Array([1,2,3,4,5,6,7,8,9,10,11,12]); // Update with actual data
                const inputGpuBuffer2 = new Float32Array([1,2,3,4,5,6,7,8,9,10,11,12]); // Update with actual data
                const a = new ort.Tensor('float32', inputGpuBuffer1, [3, 4]);
                const b = new ort.Tensor('float32', inputGpuBuffer2, [4, 3]);
                console.log(a);
                console.log(b);
                const feeds = { a: a , b: b };*/
                const output = await session.run(feeds);
                console.log(output);
                var data=output[outputNames[0]].cpuData
                var dims=output[outputNames[0]].dims
                print(dims)
                print(data[0]+","+data[1]+","+data[2]+",...")
                if(dims.length==4 && dims[0]==1 && dims[1]<=3){
                    plotBitmap( dims[1],dims[2],dims[3], data,1)
                }
        }
    // runInference();

        
        //myVNN( MultiArray.fromList(Float32, LIST(1,12), toList([1,2,3,4,5,6,7,8,9,10,11,12],Float32  ) ))

        //Var("x",3.2)// window["x"] = ...
    </script>
    <button onclick="runInference()">Inference Test</button>
    </div>
</body>
</html>
